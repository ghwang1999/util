# Project Context Snapshot

# Project Tree

```
ğŸ“ 2511031ä»£ç ä¸Šä¸‹æ–‡æå–/
â”œâ”€â”€ ğŸ“„ ai_context_snapshot.txt
â”œâ”€â”€ ğŸ“„ config.json
â”œâ”€â”€ ğŸ“„ config.md
â”œâ”€â”€ ğŸ“„ config.yaml
â”œâ”€â”€ ğŸ“„ context_generator.py
â””â”€â”€ ğŸ“„ context_generator_json.py
```

--- ai_context_snapshot.txt ---
```txt
# Project Context Snapshot

# Project Tree

```
ğŸ“ 2511031ä»£ç ä¸Šä¸‹æ–‡æå–/
â”œâ”€â”€ ğŸ“„ config.json
â”œâ”€â”€ ğŸ“„ config.md
â”œâ”€â”€ ğŸ“„ config.yaml
â”œâ”€â”€ ğŸ“„ context_generator.py
â””â”€â”€ ğŸ“„ context_generator_json.py
```

--- config.json ---
```json
{
    "output_filename": "my_ai_context.txt",
    "ignore_dirs": [
        "temp_data",
        "uploads"
    ],
    "ignore_files": [
        "settings.local.py"
    ],
    "max_file_size_kb": 500,
    "preamble_text": "è¿™æ˜¯ä¸€ä¸ªDjangoé¡¹ç›®ï¼Œè¯·å¸®æˆ‘æ£€æŸ¥models.pyæ–‡ä»¶ä¸­çš„å®‰å…¨æ¼æ´ã€‚\n\n",
    "ignore_patterns": [
        "#  Copyright (c) Huawei Technologies Co., Ltd. 2025-2025. All rights reserved."
    ]
}
```

--- config.md ---
```md
```json
{
    "output_filename": "my_ai_context.txt",
    "ignore_dirs": [
        "temp_data",
        "uploads"
    ],
    "ignore_files": [
        // "settings.local.py"
    ],
    "max_file_size_kb": 500,
    "preamble_text": "è¿™æ˜¯ä¸€ä¸ªDjangoé¡¹ç›®ï¼Œè¯·å¸®æˆ‘æ£€æŸ¥models.pyæ–‡ä»¶ä¸­çš„å®‰å…¨æ¼æ´ã€‚\n\n",
    "ignore_patterns": [
        "#  Copyright (c) Huawei Technologies Co., Ltd. 2025-2025. All rights reserved."
    ]
}
```
```

--- config.yaml ---
```yaml
# --- AI ä¸Šä¸‹æ–‡ç”Ÿæˆå™¨é…ç½® ---
# æ­¤å¤„ä¸ºè„šæœ¬é€šç”¨é…ç½®ï¼Œé¡¹ç›®çº§é…ç½®ä¸ºproject_path/.context_rules.yaml

# [æ ¸å¿ƒé…ç½®] è¦æ‰«æçš„é¡¹ç›®æ–‡ä»¶å¤¹è·¯å¾„
# '.' è¡¨ç¤º config.yaml æ–‡ä»¶æ‰€åœ¨çš„å½“å‰æ–‡ä»¶å¤¹
# ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼Œä¾‹å¦‚: '../my_other_project' æˆ– './src'
project_path: D:\PFile\é¡¹ç›®\25071è½¯ä»¶èƒ½åŠ›å¯ä¿¡\250709ç§‘ç›®ä¸€ä¸Šæœºç¼–ç¨‹\ä»£ç åº“\2511201graphrag\æ–°å»ºæ–‡ä»¶å¤¹\graphrag

# è¾“å‡ºæ–‡ä»¶çš„åç§°
output_filename: context_snapshot.txt

# [æ–°å¢] æ˜¯å¦æ‰«æå­æ–‡ä»¶å¤¹ (true: æ‰«æ, false: åªæ‰«æå½“å‰æ–‡ä»¶å¤¹)
# è®¾ç½®ä¸º false åï¼Œè„šæœ¬å°†åªæå–é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„æ–‡ä»¶ã€‚
process_subfolders: true

# [ç»Ÿä¸€é»‘åå•] 
# åŒ…å«è¦å¿½ç•¥çš„æ–‡ä»¶å¤¹åã€æ–‡ä»¶åæˆ–è·¯å¾„æ¨¡å¼
# è¿™é‡Œæ”¾æ‰€æœ‰é¡¹ç›®é€šç”¨çš„å¿½ç•¥é¡¹
ignore:
  - .git
  - .idea
  - .vscode
  - node_modules
  - venv
  - __pycache__
  - dist
  - build
  # å¿½ç•¥å¸¸è§äºŒè¿›åˆ¶å’Œæ— å…³æ–‡ä»¶
  - *.pyc
  - *.exe
  - *.dll
  - *.so
  - *.zip
  - *.pdf
  - *.jpg
  - *.png
  - package-lock.json
  - yarn.lock

# [ç»Ÿä¸€ç™½åå•]
# å…¨å±€é…ç½®é€šå¸¸ç•™ç©ºï¼Œè¡¨ç¤ºâ€œé»˜è®¤è¯»å–æ‰€æœ‰å†…å®¹â€
# å¦‚æœä½ åœ¨å…¨å±€è®¾ç½®äº†è¿™é‡Œï¼Œæ‰€æœ‰é¡¹ç›®éƒ½ä¼šå˜æˆåªè¯»å–è¿™äº›æ–‡ä»¶
include: 
  # - src/  <-- å¦‚æœå–æ¶ˆæ³¨é‡Šï¼Œæ‰€æœ‰é¡¹ç›®é»˜è®¤åªè¯» src

# å•ä¸ªæ–‡ä»¶çš„æœ€å¤§å¤§å°é™åˆ¶ (å•ä½ KB)ï¼Œè¶…è¿‡æ­¤å¤§å°çš„æ–‡ä»¶å°†è¢«è·³è¿‡
max_file_size_kb: 200

# æ·»åŠ åˆ°è¾“å‡ºæ–‡ä»¶å¼€å¤´çš„å‰è¨€æ–‡æœ¬ï¼Œå¯ä»¥ç»™ AI æä¾›æŒ‡ä»¤
# ä½¿ç”¨ | å¯ä»¥ä¿ç•™æ¢è¡Œç¬¦ï¼Œéå¸¸é€‚åˆå¤šè¡Œæ–‡æœ¬
preamble_text: |
  è¿™æ˜¯ä¸€ä¸ª Python Django é¡¹ç›®ã€‚
  è¯·å¸®æˆ‘åˆ†æä»£ç ç»“æ„ï¼Œå¹¶æ‰¾å‡ºæ½œåœ¨çš„æ€§èƒ½é—®é¢˜ã€‚

# åœ¨æ–‡ä»¶å†…å®¹ä¸­éœ€è¦å±è”½çš„è¯è¯­æˆ–å¥å­ï¼ˆæ•´è¡Œå±è”½ï¼‰
# éå¸¸é€‚åˆç”¨æ¥è¿‡æ»¤æ‰è‡ªåŠ¨ç”Ÿæˆçš„æ³¨é‡Šã€ç‰ˆæƒä¿¡æ¯æˆ–è°ƒè¯•ä»£ç 
ignore_patterns:
  # - "Copyright (c) Huawei Technologies Co., Ltd."
  # - "Copyright (c)" # å±è”½åŒ…å«ç‰ˆæƒä¿¡æ¯çš„è¡Œ
```

--- context_generator.py ---
```py
import os
import argparse
import sys
import fnmatch

try:
    import yaml
except ImportError:
    print("âŒ é”™è¯¯: PyYAML åº“æœªå®‰è£…ã€‚è¯·è¿è¡Œ 'pip install PyYAML' æ¥å®‰è£…å®ƒã€‚")
    sys.exit(1)

# --- é»˜è®¤å…¨å±€é…ç½® ---
DEFAULT_CONFIG = {
    "project_path": ".",
    "output_filename": "ai_context_snapshot.txt",
    "max_file_size_kb": 200,
    "process_subfolders": True,
    # ç»Ÿä¸€çš„é»‘åå•ï¼šæ”¯æŒæ–‡ä»¶å¤¹åã€æ–‡ä»¶åã€é€šé…ç¬¦
    "ignore": [
        ".git", "node_modules", "__pycache__", "dist", "build", ".vscode", "venv", ".idea",
        "*.pyc", "*.png", "*.jpg", "*.svg", "*.exe", "*.zip", "*.pdf", "package-lock.json"
    ],
    # ç»Ÿä¸€çš„ç™½åå•ï¼šå¦‚æœè®¾ç½®äº†å†…å®¹ï¼Œåˆ™åªæ‰«æåŒ¹é…çš„è·¯å¾„ï¼›ä¸ºç©ºåˆ™æ‰«ææ‰€æœ‰
    "include": [], 
    "preamble_text": "# Project Context Snapshot\n\n",
    "ignore_patterns": [] # å†…å®¹è¿‡æ»¤
}

PROJECT_CONFIG_NAME = ".context_rules.yaml"  # é¡¹ç›®æ–‡ä»¶å¤¹å†…çš„é…ç½®æ–‡ä»¶å

def merge_config(base_config, new_config):
    """åˆå¹¶é…ç½®ï¼šåˆ—è¡¨è¿½åŠ ï¼Œå…¶ä»–ç±»å‹è¦†ç›–"""
    if not new_config:
        return base_config
    
    merged = base_config.copy()
    for key, value in new_config.items():
        # å¤„ç† YAML ä¸­åˆ—è¡¨å…¨è¢«æ³¨é‡Šå¯¼è‡´ value ä¸º None çš„æƒ…å†µ
        if value is None:
            if isinstance(base_config.get(key), list):
                value = []
            else:
                continue # å¦‚æœä¸æ˜¯åˆ—è¡¨ä¸”ä¸ºNoneï¼Œé€šå¸¸å¿½ç•¥æˆ–ä¿æŒé»˜è®¤
        
        # åˆ—è¡¨ç±»å‹ -> è¿½åŠ  (å»é‡)
        if isinstance(value, list) and isinstance(merged.get(key), list):
            # ç®€å•çš„å»é‡åˆå¹¶ï¼Œä¿æŒé¡ºåº
            current_list = merged[key]
            for item in value:
                if item not in current_list:
                    current_list.append(item)
        # å…¶ä»–ç±»å‹ -> è¦†ç›–
        else:
            merged[key] = value
    return merged

def load_config(script_dir, project_root=None):
    """åŠ è½½å…¨å±€é…ç½®ï¼Œå¹¶å°è¯•åŠ è½½é¡¹ç›®çº§é…ç½®"""
    # 1. åŠ è½½é»˜è®¤é…ç½®
    config = DEFAULT_CONFIG.copy()
    
    # 2. åŠ è½½å…¨å±€ config.yaml
    global_config_path = os.path.join(script_dir, 'config.yaml')
    if os.path.exists(global_config_path):
        try:
            with open(global_config_path, 'r', encoding='utf-8') as f:
                global_yml = yaml.safe_load(f)
                config = merge_config(config, global_yml)
            print(f"âœ… å·²åŠ è½½å…¨å±€é…ç½®: {global_config_path}")
        except Exception as e:
            print(f"âš ï¸ åŠ è½½å…¨å±€é…ç½®å‡ºé”™: {e}")

    # 3. åŠ è½½é¡¹ç›®çº§é…ç½® (å¦‚æœå­˜åœ¨)
    if project_root:
        project_config_path = os.path.join(project_root, PROJECT_CONFIG_NAME)
        if os.path.exists(project_config_path):
            try:
                with open(project_config_path, 'r', encoding='utf-8') as f:
                    proj_yml = yaml.safe_load(f)
                    config = merge_config(config, proj_yml)
                print(f"âœ… å·²åŠ è½½é¡¹ç›®çº§é…ç½®: {project_config_path}")
            except Exception as e:
                print(f"âš ï¸ åŠ è½½é¡¹ç›®é…ç½®å‡ºé”™: {e}")
    
    # ç¡®ä¿å…³é”®å­—æ®µæ˜¯åˆ—è¡¨
    for key in ["ignore", "include", "ignore_patterns"]:
        if config.get(key) is None: config[key] = []
        
    return config

def should_ignore(name, relative_path, config):
    """æ£€æŸ¥æ–‡ä»¶/æ–‡ä»¶å¤¹æ˜¯å¦åº”è¯¥è¢«å¿½ç•¥ (é»‘åå•)"""
    ignore_rules = config.get('ignore', [])
    
    # 1. æ£€æŸ¥åç§°åŒ¹é… (å¦‚ 'node_modules', '*.pyc')
    for pattern in ignore_rules:
        if fnmatch.fnmatch(name, pattern):
            return True
            
    # 2. æ£€æŸ¥è·¯å¾„åŒ¹é… (å¦‚ 'src/temp/*')
    # å°†è·¯å¾„åˆ†éš”ç¬¦ç»Ÿä¸€ä¸º /
    normalized_path = relative_path.replace(os.sep, '/')
    for pattern in ignore_rules:
        if fnmatch.fnmatch(normalized_path, pattern):
            return True
            
    return False

def should_include(name, relative_path, config):
    """æ£€æŸ¥æ–‡ä»¶/æ–‡ä»¶å¤¹æ˜¯å¦åœ¨ç™½åå•ä¸­ (å¦‚æœæœ‰ç™½åå•)"""
    include_rules = config.get('include', [])
    
    # å¦‚æœç™½åå•ä¸ºç©ºï¼Œé»˜è®¤å…¨é€‰ (è¿”å› True)
    if not include_rules:
        return True
        
    normalized_path = relative_path.replace(os.sep, '/')
    
    # æ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»ä½•ç™½åå•è§„åˆ™
    # æ³¨æ„ï¼šå¯¹äºæ–‡ä»¶å¤¹ï¼Œå¦‚æœå®ƒæ˜¯ç™½åå•è·¯å¾„çš„çˆ¶çº§ï¼Œä¹Ÿå¿…é¡»åŒ…å«ï¼Œå¦åˆ™æ— æ³•é€’å½’è¿›å»
    # ä¾‹å¦‚ include: ['src/utils'], é‚£ä¹ˆ 'src' å¿…é¡»è¢«åŒ…å«
    
    is_match = False
    for pattern in include_rules:
        # ç²¾ç¡®åŒ¹é…æˆ–é€šé…ç¬¦åŒ¹é…
        if fnmatch.fnmatch(name, pattern) or fnmatch.fnmatch(normalized_path, pattern):
            return True
        
        # è·¯å¾„å‰ç¼€æ£€æŸ¥ (ç”¨äºé€’å½’)
        # å¦‚æœ pattern æ˜¯ 'src/utils', å½“å‰ path æ˜¯ 'src'ï¼Œåº”è¯¥å…è®¸è¿›å…¥
        if pattern.startswith(normalized_path + '/'):
            return True
            
    return False

def filter_content(content, patterns):
    if not patterns: return content
    lines = content.splitlines()
    filtered_lines = [line for line in lines if not any(p in line for p in patterns)]
    return "\n".join(filtered_lines)

def generate_file_tree(root_path, config):
    tree_lines = []
    tree_lines.append(f"ğŸ“ {os.path.basename(root_path)}/")
    
    ignore_rules = config.get('ignore', [])
    
    tree = {}
    
    for foldername, subfolders, filenames in os.walk(root_path, topdown=True):
        rel_dir = os.path.relpath(foldername, root_path)
        if rel_dir == '.': rel_dir = ''
        
        # --- è¿‡æ»¤ç›®å½• (åŸåœ°ä¿®æ”¹ subfolders) ---
        # 1. é»‘åå•è¿‡æ»¤
        subfolders[:] = [d for d in subfolders if not should_ignore(d, os.path.join(rel_dir, d), config)]
        # 2. ç™½åå•è¿‡æ»¤
        if config.get('include'):
             subfolders[:] = [d for d in subfolders if should_include(d, os.path.join(rel_dir, d), config)]
        
        # å¦‚æœä¸å¤„ç†å­æ–‡ä»¶å¤¹ï¼Œä¸”å½“å‰æ˜¯æ ¹ç›®å½•ï¼Œæ¸…ç©ºå­ç›®å½•
        if not config.get('process_subfolders', True) and foldername == root_path:
            subfolders[:] = []

        # --- è¿‡æ»¤æ–‡ä»¶ ---
        filtered_files = []
        for filename in sorted(filenames):
            file_rel_path = os.path.join(rel_dir, filename)
            
            # é»‘åå•
            if should_ignore(filename, file_rel_path, config): continue
            # ç™½åå•
            if not should_include(filename, file_rel_path, config): continue
            
            # å¤§å°æ£€æŸ¥ (æ ‘ç»“æ„å¯ä»¥ä¸æ£€æŸ¥å¤§å°ï¼Œä¹Ÿå¯ä»¥æ£€æŸ¥ï¼Œè¿™é‡Œä¸ºäº†ç®€æ´åªåœ¨è¯»å–æ—¶ä¸¥æ ¼æ£€æŸ¥)
            filtered_files.append(filename)

        # --- æ„å»ºæ ‘ ---
        path_parts = rel_dir.split(os.sep) if rel_dir else []
        current_level = tree
        for part in path_parts:
            current_level = current_level.setdefault(f"ğŸ“ {part}", {})
            
        for d in subfolders:
            current_level.setdefault(f"ğŸ“ {d}", {})
        for f in filtered_files:
            current_level[f"ğŸ“„ {f}"] = None

    def build_tree_lines(subtree, prefix=""):
        items = sorted(subtree.keys())
        for i, key in enumerate(items):
            is_last = (i == len(items) - 1)
            connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
            tree_lines.append(f"{prefix}{connector}{key}")
            if subtree[key] is not None:
                new_prefix = prefix + ("    " if is_last else "â”‚   ")
                build_tree_lines(subtree[key], new_prefix)

    build_tree_lines(tree)
    return "# Project Tree\n\n```\n" + "\n".join(tree_lines) + "\n```\n\n"

def generate_context(root_path, config):
    full_context = [config.get('preamble_text', ''), generate_file_tree(root_path, config)]
    
    print(f"å¼€å§‹æ‰«æ: {root_path}")
    
    for foldername, subfolders, filenames in os.walk(root_path, topdown=True):
        rel_dir = os.path.relpath(foldername, root_path)
        if rel_dir == '.': rel_dir = ''
        
        # --- è¿‡æ»¤ç›®å½• ---
        subfolders[:] = [d for d in subfolders if not should_ignore(d, os.path.join(rel_dir, d), config)]
        if config.get('include'):
             subfolders[:] = [d for d in subfolders if should_include(d, os.path.join(rel_dir, d), config)]
        
        if foldername == root_path and not config.get('process_subfolders', True):
             subfolders[:] = []

        # --- å¤„ç†æ–‡ä»¶ ---
        for filename in filenames:
            file_rel_path = os.path.join(rel_dir, filename)
            
            # è¿‡æ»¤
            if should_ignore(filename, file_rel_path, config): continue
            if not should_include(filename, file_rel_path, config): continue
            
            full_filepath = os.path.join(foldername, filename)
            
            try:
                if os.path.getsize(full_filepath) / 1024 > config.get('max_file_size_kb'):
                    print(f"  - è·³è¿‡å¤§æ–‡ä»¶: {file_rel_path}")
                    continue
                
                with open(full_filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                content = filter_content(content, config.get('ignore_patterns', []))
                ext = os.path.splitext(filename)[1]
                
                block = f"--- {file_rel_path} ---\n```{ext.lstrip('.')}\n{content.strip()}\n```\n\n"
                full_context.append(block)
                
            except Exception:
                pass
                
    return "".join(full_context)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="AI Context Generator")
    parser.add_argument('path', nargs='?', default=None)
    args = parser.parse_args()
    
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 1. åˆå§‹åŠ è½½è·å– project_path
    temp_config = load_config(script_dir)
    project_path = args.path if args.path else temp_config.get('project_path', '.')
    
    if not os.path.isabs(project_path):
        project_path = os.path.abspath(os.path.join(script_dir, project_path))
        
    if not os.path.isdir(project_path):
        print(f"âŒ è·¯å¾„ä¸å­˜åœ¨: {project_path}")
        sys.exit(1)
        
    # 2. é‡æ–°åŠ è½½ï¼Œè¿™æ¬¡ä¼ å…¥ project_path ä»¥è¯»å–é¡¹ç›®çº§é…ç½®
    final_config = load_config(script_dir, project_path)
    
    # æ›´æ–°æœ€ç»ˆè·¯å¾„
    final_config['project_path'] = project_path 
    
    output_content = generate_context(project_path, final_config)
    
    out_file = os.path.join(project_path, final_config['output_filename'])
    with open(out_file, 'w', encoding='utf-8') as f:
        f.write(output_content)
        
    print(f"\nâœ… å®Œæˆ! è¾“å‡ºæ–‡ä»¶: {out_file} ({len(output_content)/1024:.1f} KB)")
```

--- context_generator_json.py ---
```py
import os
import argparse
import json
import sys

# é»˜è®¤é…ç½®
DEFAULT_CONFIG = {
    "output_filename": "ai_context_snapshot.txt",
    "ignore_dirs": [
        ".git", "node_modules", "__pycache__", "dist", "build", 
        ".vscode", ".idea", "venv", "env", "logs"
    ],
    "ignore_files": [
        ".gitignore", "README.md", "LICENSE", "package-lock.json", 
        "context_generator.py", "config.json"
    ],
    "binary_extensions": [
        ".png", ".jpg", ".jpeg", ".svg", ".ico", ".pdf", ".zip", 
        ".tar", ".gz", ".exe", ".dll", ".bin", ".mp4", ".mov"
    ],
    "max_file_size_kb": 200,
    "preamble_text": "# Project Context Snapshot\n\n",
    "ignore_patterns": [] # æ–°å¢ï¼šç”¨äºå±è”½ç‰¹å®šè¯è¯­æˆ–å¥å­çš„åˆ—è¡¨
}

def load_config(root_path):
    """å°è¯•ä»é¡¹ç›®æ ¹ç›®å½•åŠ è½½é…ç½®ï¼Œå¹¶åˆå¹¶é»˜è®¤é…ç½®ã€‚"""
    config_path = os.path.join(root_path, 'config.json')
    user_config = {}
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                user_config = json.load(f)
            print(f"âœ… æˆåŠŸåŠ è½½é…ç½®æ–‡ä»¶: {config_path}")
        except json.JSONDecodeError:
            print(f"âŒ é”™è¯¯: é…ç½®æ–‡ä»¶ '{config_path}' æ ¼å¼ä¸æ­£ç¡®ï¼Œå°†ä½¿ç”¨é»˜è®¤é…ç½®ã€‚")
        except Exception as e:
            print(f"âŒ é”™è¯¯: è¯»å–é…ç½®æ–‡ä»¶æ—¶å‘ç”Ÿæ„å¤–é”™è¯¯: {e}")
            
    config = DEFAULT_CONFIG.copy()
    config.update(user_config)
    return config

def get_syntax_lang(filepath):
    """æ ¹æ®æ–‡ä»¶æ‰©å±•åè¿”å›ä»£ç å—è¯­è¨€æç¤º"""
    extension_map = {
        '.py': 'python', '.js': 'javascript', '.ts': 'typescript',
        '.jsx': 'jsx', '.tsx': 'tsx', '.html': 'html',
        '.css': 'css', '.scss': 'scss', '.json': 'json',
        '.md': 'markdown', '.java': 'java', '.go': 'go',
        '.sh': 'bash', '.yaml': 'yaml', '.yml': 'yaml',
    }
    ext = os.path.splitext(filepath)[1].lower()
    return extension_map.get(ext, '')

def filter_content(content, patterns):
    """æ ¹æ®æä¾›çš„æ¨¡å¼åˆ—è¡¨è¿‡æ»¤æ–‡ä»¶å†…å®¹ã€‚"""
    if not patterns:
        return content
    
    lines = content.splitlines()
    # åªä¿ç•™ä¸åŒ…å«ä»»ä½•å±è”½æ¨¡å¼çš„è¡Œ
    filtered_lines = [line for line in lines if not any(pattern in line for pattern in patterns)]
    return "\n".join(filtered_lines)

def generate_context(root_path, config):
    """éå†æ–‡ä»¶å¤¹å¹¶ç”Ÿæˆä»£ç ä¸Šä¸‹æ–‡"""
    full_context = [config['preamble_text']]
    root_path = os.path.abspath(root_path)
    ignore_patterns = config.get('ignore_patterns', [])
    
    for foldername, subfolders, filenames in os.walk(root_path, topdown=True):
        
        subfolders[:] = [d for d in subfolders if d not in config['ignore_dirs']]

        for filename in filenames:
            
            full_filepath = os.path.join(foldername, filename)
            relative_path = os.path.relpath(full_filepath, root_path)
            
            if filename in config['ignore_files']: continue
            if any(relative_path.lower().endswith(ext) for ext in config['binary_extensions']): continue
            
            try:
                if os.path.getsize(full_filepath) / 1024 > config['max_file_size_kb']:
                    print(f"è·³è¿‡è¿‡å¤§æ–‡ä»¶: {relative_path}")
                    continue
            except Exception:
                continue

            try:
                with open(full_filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # --- æ–°å¢ï¼šå†…å®¹è¿‡æ»¤ ---
                filtered_content = filter_content(content, ignore_patterns)
                # ---------------------
                
                lang = get_syntax_lang(relative_path)
                
                block = (
                    f"{relative_path}\n"
                    f"```{lang}\n"
                    f"{filtered_content.strip()}\n"
                    f"```\n\n"
                )
                full_context.append(block)
                
            except UnicodeDecodeError:
                pass
            except Exception as e:
                print(f"å¤„ç†æ–‡ä»¶ {relative_path} æ—¶å‘ç”Ÿé”™è¯¯: {e}")

    return "".join(full_context)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="ä¸º AI ä¸Šä¸‹æ–‡ç”Ÿæˆé¡¹ç›®ä»£ç å¿«ç…§ã€‚")
    parser.add_argument('project_path', nargs='?', default='.', help='é¡¹ç›®æ–‡ä»¶å¤¹çš„è·¯å¾„ (ä¾‹å¦‚: . æˆ– /path/to/my/project)')
    args = parser.parse_args()
    
    project_root = args.project_path
    
    config = load_config(project_root)
    output_filename = config['output_filename']
    
    print(f"æ­£åœ¨æ‰«æé¡¹ç›®: {os.path.abspath(project_root)}")
    
    context = generate_context(project_root, config)
    
    try:
        output_filepath = os.path.join(project_root, output_filename)
        with open(output_filepath, 'w', encoding='utf-8') as f:
            f.write(context)
            
        print("-" * 50)
        print(f"âœ… ä¸Šä¸‹æ–‡å·²æˆåŠŸç”Ÿæˆå¹¶ä¿å­˜åˆ°æ–‡ä»¶: {output_filepath}")
        print(f"æ–‡ä»¶å¤§å°: {len(context) / 1024:.2f} KB")
        print("è¯·å¤åˆ¶è¯¥æ–‡ä»¶çš„å†…å®¹ç”¨äº AI äº¤æµã€‚")
        print("-" * 50)
        
    except Exception as e:
        print(f"âŒ å†™å…¥æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {e}")
        sys.exit(1)
```
```

--- config.json ---
```json
{
    "output_filename": "my_ai_context.txt",
    "ignore_dirs": [
        "temp_data",
        "uploads"
    ],
    "ignore_files": [
        "settings.local.py"
    ],
    "max_file_size_kb": 500,
    "preamble_text": "è¿™æ˜¯ä¸€ä¸ªDjangoé¡¹ç›®ï¼Œè¯·å¸®æˆ‘æ£€æŸ¥models.pyæ–‡ä»¶ä¸­çš„å®‰å…¨æ¼æ´ã€‚\n\n",
    "ignore_patterns": [
        "#  Copyright (c) Huawei Technologies Co., Ltd. 2025-2025. All rights reserved."
    ]
}
```

--- config.md ---
```md
```json
{
    "output_filename": "my_ai_context.txt",
    "ignore_dirs": [
        "temp_data",
        "uploads"
    ],
    "ignore_files": [
        // "settings.local.py"
    ],
    "max_file_size_kb": 500,
    "preamble_text": "è¿™æ˜¯ä¸€ä¸ªDjangoé¡¹ç›®ï¼Œè¯·å¸®æˆ‘æ£€æŸ¥models.pyæ–‡ä»¶ä¸­çš„å®‰å…¨æ¼æ´ã€‚\n\n",
    "ignore_patterns": [
        "#  Copyright (c) Huawei Technologies Co., Ltd. 2025-2025. All rights reserved."
    ]
}
```
```

--- config.yaml ---
```yaml
# --- AI ä¸Šä¸‹æ–‡ç”Ÿæˆå™¨é…ç½® ---
# æ­¤å¤„ä¸ºè„šæœ¬é€šç”¨é…ç½®ï¼Œé¡¹ç›®çº§é…ç½®ä¸ºproject_path/.context_rules.yaml

# [æ ¸å¿ƒé…ç½®] è¦æ‰«æçš„é¡¹ç›®æ–‡ä»¶å¤¹è·¯å¾„
# '.' è¡¨ç¤º config.yaml æ–‡ä»¶æ‰€åœ¨çš„å½“å‰æ–‡ä»¶å¤¹
# ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼Œä¾‹å¦‚: '../my_other_project' æˆ– './src'
project_path: D:\PFile\é¡¹ç›®\25071è½¯ä»¶èƒ½åŠ›å¯ä¿¡\250709ç§‘ç›®ä¸€ä¸Šæœºç¼–ç¨‹\ä»£ç åº“\2511201graphrag\æ–°å»ºæ–‡ä»¶å¤¹\graphrag

# è¾“å‡ºæ–‡ä»¶çš„åç§°
output_filename: context_snapshot.txt

# [æ–°å¢] æ˜¯å¦æ‰«æå­æ–‡ä»¶å¤¹ (true: æ‰«æ, false: åªæ‰«æå½“å‰æ–‡ä»¶å¤¹)
# è®¾ç½®ä¸º false åï¼Œè„šæœ¬å°†åªæå–é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„æ–‡ä»¶ã€‚
process_subfolders: true

# [ç»Ÿä¸€é»‘åå•] 
# åŒ…å«è¦å¿½ç•¥çš„æ–‡ä»¶å¤¹åã€æ–‡ä»¶åæˆ–è·¯å¾„æ¨¡å¼
# è¿™é‡Œæ”¾æ‰€æœ‰é¡¹ç›®é€šç”¨çš„å¿½ç•¥é¡¹
ignore:
  - .git
  - .idea
  - .vscode
  - node_modules
  - venv
  - __pycache__
  - dist
  - build
  - *.pyc   # å¿½ç•¥å¸¸è§äºŒè¿›åˆ¶å’Œæ— å…³æ–‡ä»¶
  - *.exe
  - *.dll
  - *.so
  - *.zip
  - *.pdf
  - *.jpg
  - *.png
  - package-lock.json
  - yarn.lock

# [ç»Ÿä¸€ç™½åå•]
# å…¨å±€é…ç½®é€šå¸¸ç•™ç©ºï¼Œè¡¨ç¤ºâ€œé»˜è®¤è¯»å–æ‰€æœ‰å†…å®¹â€
# å¦‚æœä½ åœ¨å…¨å±€è®¾ç½®äº†è¿™é‡Œï¼Œæ‰€æœ‰é¡¹ç›®éƒ½ä¼šå˜æˆåªè¯»å–è¿™äº›æ–‡ä»¶
include: 
  # - src/  <-- å¦‚æœå–æ¶ˆæ³¨é‡Šï¼Œæ‰€æœ‰é¡¹ç›®é»˜è®¤åªè¯» src

# å•ä¸ªæ–‡ä»¶çš„æœ€å¤§å¤§å°é™åˆ¶ (å•ä½ KB)ï¼Œè¶…è¿‡æ­¤å¤§å°çš„æ–‡ä»¶å°†è¢«è·³è¿‡
max_file_size_kb: 200

# æ·»åŠ åˆ°è¾“å‡ºæ–‡ä»¶å¼€å¤´çš„å‰è¨€æ–‡æœ¬ï¼Œå¯ä»¥ç»™ AI æä¾›æŒ‡ä»¤
# ä½¿ç”¨ | å¯ä»¥ä¿ç•™æ¢è¡Œç¬¦ï¼Œéå¸¸é€‚åˆå¤šè¡Œæ–‡æœ¬
preamble_text: |
  è¿™æ˜¯ä¸€ä¸ª Python Django é¡¹ç›®ã€‚
  è¯·å¸®æˆ‘åˆ†æä»£ç ç»“æ„ï¼Œå¹¶æ‰¾å‡ºæ½œåœ¨çš„æ€§èƒ½é—®é¢˜ã€‚

# åœ¨æ–‡ä»¶å†…å®¹ä¸­éœ€è¦å±è”½çš„è¯è¯­æˆ–å¥å­ï¼ˆæ•´è¡Œå±è”½ï¼‰
# éå¸¸é€‚åˆç”¨æ¥è¿‡æ»¤æ‰è‡ªåŠ¨ç”Ÿæˆçš„æ³¨é‡Šã€ç‰ˆæƒä¿¡æ¯æˆ–è°ƒè¯•ä»£ç 
ignore_patterns:
  # - "Copyright (c) Huawei Technologies Co., Ltd."
  # - "Copyright (c)" # å±è”½åŒ…å«ç‰ˆæƒä¿¡æ¯çš„è¡Œ
```

--- context_generator.py ---
```py
import os
import argparse
import sys
import fnmatch

try:
    import yaml
except ImportError:
    print("âŒ é”™è¯¯: PyYAML åº“æœªå®‰è£…ã€‚è¯·è¿è¡Œ 'pip install PyYAML' æ¥å®‰è£…å®ƒã€‚")
    sys.exit(1)

# --- é»˜è®¤å…¨å±€é…ç½® ---
DEFAULT_CONFIG = {
    "project_path": ".",
    "output_filename": "ai_context_snapshot.txt",
    "max_file_size_kb": 200,
    "process_subfolders": True,
    # ç»Ÿä¸€çš„é»‘åå•ï¼šæ”¯æŒæ–‡ä»¶å¤¹åã€æ–‡ä»¶åã€é€šé…ç¬¦
    "ignore": [
        ".git", "node_modules", "__pycache__", "dist", "build", ".vscode", "venv", ".idea",
        "*.pyc", "*.png", "*.jpg", "*.svg", "*.exe", "*.zip", "*.pdf", "package-lock.json"
    ],
    # ç»Ÿä¸€çš„ç™½åå•ï¼šå¦‚æœè®¾ç½®äº†å†…å®¹ï¼Œåˆ™åªæ‰«æåŒ¹é…çš„è·¯å¾„ï¼›ä¸ºç©ºåˆ™æ‰«ææ‰€æœ‰
    "include": [], 
    "preamble_text": "# Project Context Snapshot\n\n",
    "ignore_patterns": [] # å†…å®¹è¿‡æ»¤
}

PROJECT_CONFIG_NAME = ".context_rules.yaml"  # é¡¹ç›®æ–‡ä»¶å¤¹å†…çš„é…ç½®æ–‡ä»¶å

def merge_config(base_config, new_config):
    """åˆå¹¶é…ç½®ï¼šåˆ—è¡¨è¿½åŠ ï¼Œå…¶ä»–ç±»å‹è¦†ç›–"""
    if not new_config:
        return base_config
    
    merged = base_config.copy()
    for key, value in new_config.items():
        # å¤„ç† YAML ä¸­åˆ—è¡¨å…¨è¢«æ³¨é‡Šå¯¼è‡´ value ä¸º None çš„æƒ…å†µ
        if value is None:
            if isinstance(base_config.get(key), list):
                value = []
            else:
                continue # å¦‚æœä¸æ˜¯åˆ—è¡¨ä¸”ä¸ºNoneï¼Œé€šå¸¸å¿½ç•¥æˆ–ä¿æŒé»˜è®¤
        
        # åˆ—è¡¨ç±»å‹ -> è¿½åŠ  (å»é‡)
        if isinstance(value, list) and isinstance(merged.get(key), list):
            # ç®€å•çš„å»é‡åˆå¹¶ï¼Œä¿æŒé¡ºåº
            current_list = merged[key]
            for item in value:
                if item not in current_list:
                    current_list.append(item)
        # å…¶ä»–ç±»å‹ -> è¦†ç›–
        else:
            merged[key] = value
    return merged

def load_config(script_dir, project_root=None):
    """åŠ è½½å…¨å±€é…ç½®ï¼Œå¹¶å°è¯•åŠ è½½é¡¹ç›®çº§é…ç½®"""
    # 1. åŠ è½½é»˜è®¤é…ç½®
    config = DEFAULT_CONFIG.copy()
    
    # 2. åŠ è½½å…¨å±€ config.yaml
    global_config_path = os.path.join(script_dir, 'config.yaml')
    if os.path.exists(global_config_path):
        try:
            with open(global_config_path, 'r', encoding='utf-8') as f:
                global_yml = yaml.safe_load(f)
                config = merge_config(config, global_yml)
            print(f"âœ… å·²åŠ è½½å…¨å±€é…ç½®: {global_config_path}")
        except Exception as e:
            print(f"âš ï¸ åŠ è½½å…¨å±€é…ç½®å‡ºé”™: {e}")

    # 3. åŠ è½½é¡¹ç›®çº§é…ç½® (å¦‚æœå­˜åœ¨)
    if project_root:
        project_config_path = os.path.join(project_root, PROJECT_CONFIG_NAME)
        if os.path.exists(project_config_path):
            try:
                with open(project_config_path, 'r', encoding='utf-8') as f:
                    proj_yml = yaml.safe_load(f)
                    config = merge_config(config, proj_yml)
                print(f"âœ… å·²åŠ è½½é¡¹ç›®çº§é…ç½®: {project_config_path}")
            except Exception as e:
                print(f"âš ï¸ åŠ è½½é¡¹ç›®é…ç½®å‡ºé”™: {e}")
    
    # ç¡®ä¿å…³é”®å­—æ®µæ˜¯åˆ—è¡¨
    for key in ["ignore", "include", "ignore_patterns"]:
        if config.get(key) is None: config[key] = []
        
    return config

def should_ignore(name, relative_path, config):
    """æ£€æŸ¥æ–‡ä»¶/æ–‡ä»¶å¤¹æ˜¯å¦åº”è¯¥è¢«å¿½ç•¥ (é»‘åå•)"""
    ignore_rules = config.get('ignore', [])
    
    # 1. æ£€æŸ¥åç§°åŒ¹é… (å¦‚ 'node_modules', '*.pyc')
    for pattern in ignore_rules:
        if fnmatch.fnmatch(name, pattern):
            return True
            
    # 2. æ£€æŸ¥è·¯å¾„åŒ¹é… (å¦‚ 'src/temp/*')
    # å°†è·¯å¾„åˆ†éš”ç¬¦ç»Ÿä¸€ä¸º /
    normalized_path = relative_path.replace(os.sep, '/')
    for pattern in ignore_rules:
        if fnmatch.fnmatch(normalized_path, pattern):
            return True
            
    return False

def should_include(name, relative_path, config):
    """æ£€æŸ¥æ–‡ä»¶/æ–‡ä»¶å¤¹æ˜¯å¦åœ¨ç™½åå•ä¸­ (å¦‚æœæœ‰ç™½åå•)"""
    include_rules = config.get('include', [])
    
    # å¦‚æœç™½åå•ä¸ºç©ºï¼Œé»˜è®¤å…¨é€‰ (è¿”å› True)
    if not include_rules:
        return True
        
    normalized_path = relative_path.replace(os.sep, '/')
    
    # æ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»ä½•ç™½åå•è§„åˆ™
    # æ³¨æ„ï¼šå¯¹äºæ–‡ä»¶å¤¹ï¼Œå¦‚æœå®ƒæ˜¯ç™½åå•è·¯å¾„çš„çˆ¶çº§ï¼Œä¹Ÿå¿…é¡»åŒ…å«ï¼Œå¦åˆ™æ— æ³•é€’å½’è¿›å»
    # ä¾‹å¦‚ include: ['src/utils'], é‚£ä¹ˆ 'src' å¿…é¡»è¢«åŒ…å«
    
    is_match = False
    for pattern in include_rules:
        # ç²¾ç¡®åŒ¹é…æˆ–é€šé…ç¬¦åŒ¹é…
        if fnmatch.fnmatch(name, pattern) or fnmatch.fnmatch(normalized_path, pattern):
            return True
        
        # è·¯å¾„å‰ç¼€æ£€æŸ¥ (ç”¨äºé€’å½’)
        # å¦‚æœ pattern æ˜¯ 'src/utils', å½“å‰ path æ˜¯ 'src'ï¼Œåº”è¯¥å…è®¸è¿›å…¥
        if pattern.startswith(normalized_path + '/'):
            return True
            
    return False

def filter_content(content, patterns):
    if not patterns: return content
    lines = content.splitlines()
    filtered_lines = [line for line in lines if not any(p in line for p in patterns)]
    return "\n".join(filtered_lines)

def generate_file_tree(root_path, config):
    tree_lines = []
    tree_lines.append(f"ğŸ“ {os.path.basename(root_path)}/")
    
    ignore_rules = config.get('ignore', [])
    
    tree = {}
    
    for foldername, subfolders, filenames in os.walk(root_path, topdown=True):
        rel_dir = os.path.relpath(foldername, root_path)
        if rel_dir == '.': rel_dir = ''
        
        # --- è¿‡æ»¤ç›®å½• (åŸåœ°ä¿®æ”¹ subfolders) ---
        # 1. é»‘åå•è¿‡æ»¤
        subfolders[:] = [d for d in subfolders if not should_ignore(d, os.path.join(rel_dir, d), config)]
        # 2. ç™½åå•è¿‡æ»¤
        if config.get('include'):
             subfolders[:] = [d for d in subfolders if should_include(d, os.path.join(rel_dir, d), config)]
        
        # å¦‚æœä¸å¤„ç†å­æ–‡ä»¶å¤¹ï¼Œä¸”å½“å‰æ˜¯æ ¹ç›®å½•ï¼Œæ¸…ç©ºå­ç›®å½•
        if not config.get('process_subfolders', True) and foldername == root_path:
            subfolders[:] = []

        # --- è¿‡æ»¤æ–‡ä»¶ ---
        filtered_files = []
        for filename in sorted(filenames):
            file_rel_path = os.path.join(rel_dir, filename)
            
            # é»‘åå•
            if should_ignore(filename, file_rel_path, config): continue
            # ç™½åå•
            if not should_include(filename, file_rel_path, config): continue
            
            # å¤§å°æ£€æŸ¥ (æ ‘ç»“æ„å¯ä»¥ä¸æ£€æŸ¥å¤§å°ï¼Œä¹Ÿå¯ä»¥æ£€æŸ¥ï¼Œè¿™é‡Œä¸ºäº†ç®€æ´åªåœ¨è¯»å–æ—¶ä¸¥æ ¼æ£€æŸ¥)
            filtered_files.append(filename)

        # --- æ„å»ºæ ‘ ---
        path_parts = rel_dir.split(os.sep) if rel_dir else []
        current_level = tree
        for part in path_parts:
            current_level = current_level.setdefault(f"ğŸ“ {part}", {})
            
        for d in subfolders:
            current_level.setdefault(f"ğŸ“ {d}", {})
        for f in filtered_files:
            current_level[f"ğŸ“„ {f}"] = None

    def build_tree_lines(subtree, prefix=""):
        items = sorted(subtree.keys())
        for i, key in enumerate(items):
            is_last = (i == len(items) - 1)
            connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
            tree_lines.append(f"{prefix}{connector}{key}")
            if subtree[key] is not None:
                new_prefix = prefix + ("    " if is_last else "â”‚   ")
                build_tree_lines(subtree[key], new_prefix)

    build_tree_lines(tree)
    return "# Project Tree\n\n```\n" + "\n".join(tree_lines) + "\n```\n\n"

def generate_context(root_path, config):
    full_context = [config.get('preamble_text', ''), generate_file_tree(root_path, config)]
    
    print(f"å¼€å§‹æ‰«æ: {root_path}")
    
    for foldername, subfolders, filenames in os.walk(root_path, topdown=True):
        rel_dir = os.path.relpath(foldername, root_path)
        if rel_dir == '.': rel_dir = ''
        
        # --- è¿‡æ»¤ç›®å½• ---
        subfolders[:] = [d for d in subfolders if not should_ignore(d, os.path.join(rel_dir, d), config)]
        if config.get('include'):
             subfolders[:] = [d for d in subfolders if should_include(d, os.path.join(rel_dir, d), config)]
        
        if foldername == root_path and not config.get('process_subfolders', True):
             subfolders[:] = []

        # --- å¤„ç†æ–‡ä»¶ ---
        for filename in filenames:
            file_rel_path = os.path.join(rel_dir, filename)
            
            # è¿‡æ»¤
            if should_ignore(filename, file_rel_path, config): continue
            if not should_include(filename, file_rel_path, config): continue
            
            full_filepath = os.path.join(foldername, filename)
            
            try:
                if os.path.getsize(full_filepath) / 1024 > config.get('max_file_size_kb'):
                    print(f"  - è·³è¿‡å¤§æ–‡ä»¶: {file_rel_path}")
                    continue
                
                with open(full_filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                content = filter_content(content, config.get('ignore_patterns', []))
                ext = os.path.splitext(filename)[1]
                
                block = f"--- {file_rel_path} ---\n```{ext.lstrip('.')}\n{content.strip()}\n```\n\n"
                full_context.append(block)
                
            except Exception:
                pass
                
    return "".join(full_context)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="AI Context Generator")
    parser.add_argument('path', nargs='?', default=None)
    args = parser.parse_args()
    
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 1. åˆå§‹åŠ è½½è·å– project_path
    temp_config = load_config(script_dir)
    project_path = args.path if args.path else temp_config.get('project_path', '.')
    
    if not os.path.isabs(project_path):
        project_path = os.path.abspath(os.path.join(script_dir, project_path))
        
    if not os.path.isdir(project_path):
        print(f"âŒ è·¯å¾„ä¸å­˜åœ¨: {project_path}")
        sys.exit(1)
        
    # 2. é‡æ–°åŠ è½½ï¼Œè¿™æ¬¡ä¼ å…¥ project_path ä»¥è¯»å–é¡¹ç›®çº§é…ç½®
    final_config = load_config(script_dir, project_path)
    
    # æ›´æ–°æœ€ç»ˆè·¯å¾„
    final_config['project_path'] = project_path 
    
    output_content = generate_context(project_path, final_config)
    
    out_file = os.path.join(project_path, final_config['output_filename'])
    with open(out_file, 'w', encoding='utf-8') as f:
        f.write(output_content)
        
    print(f"\nâœ… å®Œæˆ! è¾“å‡ºæ–‡ä»¶: {out_file} ({len(output_content)/1024:.1f} KB)")
```

--- context_generator_json.py ---
```py
import os
import argparse
import json
import sys

# é»˜è®¤é…ç½®
DEFAULT_CONFIG = {
    "output_filename": "ai_context_snapshot.txt",
    "ignore_dirs": [
        ".git", "node_modules", "__pycache__", "dist", "build", 
        ".vscode", ".idea", "venv", "env", "logs"
    ],
    "ignore_files": [
        ".gitignore", "README.md", "LICENSE", "package-lock.json", 
        "context_generator.py", "config.json"
    ],
    "binary_extensions": [
        ".png", ".jpg", ".jpeg", ".svg", ".ico", ".pdf", ".zip", 
        ".tar", ".gz", ".exe", ".dll", ".bin", ".mp4", ".mov"
    ],
    "max_file_size_kb": 200,
    "preamble_text": "# Project Context Snapshot\n\n",
    "ignore_patterns": [] # æ–°å¢ï¼šç”¨äºå±è”½ç‰¹å®šè¯è¯­æˆ–å¥å­çš„åˆ—è¡¨
}

def load_config(root_path):
    """å°è¯•ä»é¡¹ç›®æ ¹ç›®å½•åŠ è½½é…ç½®ï¼Œå¹¶åˆå¹¶é»˜è®¤é…ç½®ã€‚"""
    config_path = os.path.join(root_path, 'config.json')
    user_config = {}
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                user_config = json.load(f)
            print(f"âœ… æˆåŠŸåŠ è½½é…ç½®æ–‡ä»¶: {config_path}")
        except json.JSONDecodeError:
            print(f"âŒ é”™è¯¯: é…ç½®æ–‡ä»¶ '{config_path}' æ ¼å¼ä¸æ­£ç¡®ï¼Œå°†ä½¿ç”¨é»˜è®¤é…ç½®ã€‚")
        except Exception as e:
            print(f"âŒ é”™è¯¯: è¯»å–é…ç½®æ–‡ä»¶æ—¶å‘ç”Ÿæ„å¤–é”™è¯¯: {e}")
            
    config = DEFAULT_CONFIG.copy()
    config.update(user_config)
    return config

def get_syntax_lang(filepath):
    """æ ¹æ®æ–‡ä»¶æ‰©å±•åè¿”å›ä»£ç å—è¯­è¨€æç¤º"""
    extension_map = {
        '.py': 'python', '.js': 'javascript', '.ts': 'typescript',
        '.jsx': 'jsx', '.tsx': 'tsx', '.html': 'html',
        '.css': 'css', '.scss': 'scss', '.json': 'json',
        '.md': 'markdown', '.java': 'java', '.go': 'go',
        '.sh': 'bash', '.yaml': 'yaml', '.yml': 'yaml',
    }
    ext = os.path.splitext(filepath)[1].lower()
    return extension_map.get(ext, '')

def filter_content(content, patterns):
    """æ ¹æ®æä¾›çš„æ¨¡å¼åˆ—è¡¨è¿‡æ»¤æ–‡ä»¶å†…å®¹ã€‚"""
    if not patterns:
        return content
    
    lines = content.splitlines()
    # åªä¿ç•™ä¸åŒ…å«ä»»ä½•å±è”½æ¨¡å¼çš„è¡Œ
    filtered_lines = [line for line in lines if not any(pattern in line for pattern in patterns)]
    return "\n".join(filtered_lines)

def generate_context(root_path, config):
    """éå†æ–‡ä»¶å¤¹å¹¶ç”Ÿæˆä»£ç ä¸Šä¸‹æ–‡"""
    full_context = [config['preamble_text']]
    root_path = os.path.abspath(root_path)
    ignore_patterns = config.get('ignore_patterns', [])
    
    for foldername, subfolders, filenames in os.walk(root_path, topdown=True):
        
        subfolders[:] = [d for d in subfolders if d not in config['ignore_dirs']]

        for filename in filenames:
            
            full_filepath = os.path.join(foldername, filename)
            relative_path = os.path.relpath(full_filepath, root_path)
            
            if filename in config['ignore_files']: continue
            if any(relative_path.lower().endswith(ext) for ext in config['binary_extensions']): continue
            
            try:
                if os.path.getsize(full_filepath) / 1024 > config['max_file_size_kb']:
                    print(f"è·³è¿‡è¿‡å¤§æ–‡ä»¶: {relative_path}")
                    continue
            except Exception:
                continue

            try:
                with open(full_filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # --- æ–°å¢ï¼šå†…å®¹è¿‡æ»¤ ---
                filtered_content = filter_content(content, ignore_patterns)
                # ---------------------
                
                lang = get_syntax_lang(relative_path)
                
                block = (
                    f"{relative_path}\n"
                    f"```{lang}\n"
                    f"{filtered_content.strip()}\n"
                    f"```\n\n"
                )
                full_context.append(block)
                
            except UnicodeDecodeError:
                pass
            except Exception as e:
                print(f"å¤„ç†æ–‡ä»¶ {relative_path} æ—¶å‘ç”Ÿé”™è¯¯: {e}")

    return "".join(full_context)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="ä¸º AI ä¸Šä¸‹æ–‡ç”Ÿæˆé¡¹ç›®ä»£ç å¿«ç…§ã€‚")
    parser.add_argument('project_path', nargs='?', default='.', help='é¡¹ç›®æ–‡ä»¶å¤¹çš„è·¯å¾„ (ä¾‹å¦‚: . æˆ– /path/to/my/project)')
    args = parser.parse_args()
    
    project_root = args.project_path
    
    config = load_config(project_root)
    output_filename = config['output_filename']
    
    print(f"æ­£åœ¨æ‰«æé¡¹ç›®: {os.path.abspath(project_root)}")
    
    context = generate_context(project_root, config)
    
    try:
        output_filepath = os.path.join(project_root, output_filename)
        with open(output_filepath, 'w', encoding='utf-8') as f:
            f.write(context)
            
        print("-" * 50)
        print(f"âœ… ä¸Šä¸‹æ–‡å·²æˆåŠŸç”Ÿæˆå¹¶ä¿å­˜åˆ°æ–‡ä»¶: {output_filepath}")
        print(f"æ–‡ä»¶å¤§å°: {len(context) / 1024:.2f} KB")
        print("è¯·å¤åˆ¶è¯¥æ–‡ä»¶çš„å†…å®¹ç”¨äº AI äº¤æµã€‚")
        print("-" * 50)
        
    except Exception as e:
        print(f"âŒ å†™å…¥æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {e}")
        sys.exit(1)
```

